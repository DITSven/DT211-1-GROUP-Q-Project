#pragma config(Sensor, S1, LightSensor, sensorLightActive)
#define ROW 7
#define COL 9
#define LSIZE 2

void ForwardOneSquare(void);
int dir LeftTurn(int circle);
int dir RightTurn(int circle);
int map[][] setSquareBlack(int map[][]], int square[]);
int next[] setNextSquare(int next[], int dir);
int loc[] setCurrentSquare(int next[]);
int obj[] foundObj1(int next[]);
int obj[] foundObj2(int next[]);
int array[][] setSquareWhite(int array[][]], int square[]);
float object_dir[] findObjectAngle(int loc[], int obj[]);
void goHome(int cur[], int start[]);

task main()
{
 int i;
 int j;

 /* Accurate turns calculation */
 //variables to store calculation data.
 float c_rotation;
 float c_distance;
 float temp;
 float circle;

 //variables to store initial values.
 float d1 = 51.0;// radius of wheel
 float d2 = 102.0;// lenght between both wheels
 float pie = 3.141592;

 //Calculation.
 c_rotation = (pie * d1);
 c_distance =(pie * d2);
 temp = (c_distance / c_rotation);
 circle = (temp * c_distance);

 //Mapping and direction tracking values
 //direction int
 //1 = col+1, 2 = row+1
 //3 = col-1, 4 = row-1
 int dir = 1;

 //map array
 int map[ROW][COL] = {0};
 //current location array
 int loc[LSIZE] = {3,0};
 //next square array
 int next[LSIZE];
 //start location square array
 const int start[LSIZE] = {3,0};
 //object1 location array
 int object1[LSIZE];
 //object2 location array
 int object2[LSIZE];
 //objects found count
 int found_objects = 0;
 //arrays to hold data for moving
 //to found objects from start position
 //element 0 = distance
 //element 1 = radians
 float go_to_object1[LSIZE];
 float go_to_object2[LSIZE];
 
 
 /* Thresholdvalue */

 int light; // Variable to hold light value
 int Dark; // Variable to hold dark value
 int sum; // Variable to hold sum value
 int thresholdValue; // Variable to hold threshold value

 light = 65;
 Dark = 30;
 sum = light + Dark;
 thresholdValue = sum/2;

 wait1Msec(1000);

 int r = random(2);
 while(found_objects < 2)
 {
 while(SensorValue(sonarSensor) > 26)
 {
 if(SensorValue(LightSensor) < thresholdValue)
 {
 nxtDisplayCenteredTextLine(4, "Black cell");
 map = setSquareBlack(map, next);

 if(r == 1)
 {
 dir = LeftTurn(circle);
 }
 else
 {
 dir = RightTurn(circle);
 }

 next = setNextSquare(next, dir);

 } // End if()
 else
 {
 nxtDisplayCenteredTextLine(4, "white cell");
 map = setSquareWhite(map, next);
 ForwardOneSquare();
 loc = setCurrentSquare(next);
 next = setNextSquare(next, dir);
 } // End else()
 }//end while()
 int found_objects = found_objects + 1;
 goHome();
 } // End while()
go_to_object1 = findObjectAngle(start, object1);
go_to_object2 = findObjectangle(start, object2);
}

void ForwardOneSquare() // Forward function
{
 int distance_square = 290;// width of the square


 nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
 nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

 nMotorEncoder[motorB] = 0;
 nMotorEncoder[motorC] = 0;

 nMotorEncoderTarget[motorB] = distance_square;
 nMotorEncoderTarget[motorC] = distance_square;

 motor[motorB] = 20;
 motor[motorC] = 20;

 while(nMotorRunState[motorC] != runStateIdle)
 {
 wait1Msec(1000);
 }


 motor[motorB] = 0;
 motor[motorC] = 0;


} // End function

void LeftTurn(int circle)
{


 nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
 nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

 nMotorEncoder[motorB] = 0;
 nMotorEncoder[motorC] = 0;

 nMotorEncoderTarget[motorB] = circle *0.25;
 nMotorEncoderTarget[motorC] = -circle * 0.25;

 motor[motorB] = 20;
 motor[motorC] = -20;

 while(nMotorRunState[motorB] != runStateIdle)
 {

 }


 motor[motorB] = 0;
 motor[motorC] = 0;

 if(dir = 1)
 {
 dir = 4;
 }//end if
 if(dir = 2)
 {
 dir = 1;
 }//end if
 if(dir = 3)
 {
 dir = 2
 }//end if
 if(dir = 4)
 {
 dir = 3;
 }//end if
}

void RightTurn(int circle)
{



 nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
 nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

 nMotorEncoder[motorB] = 0;
 nMotorEncoder[motorC] = 0;

 nMotorEncoderTarget[motorB] = -circle *0.25;
 nMotorEncoderTarget[motorC] = circle * 0.25;

 motor[motorB] = -20;
 motor[motorC] = 20;

 while(nMotorRunState[motorB] != runStateIdle)
 {

 }


 motor[motorB] = 0;
 motor[motorC] = 0;

 if(dir = 1)
 {
 dir = 2;
 }//end if
 if(dir = 2)
 {
 dir = 3;
 }//end if
 if(dir = 3)
 {
 dir = 4
 }//end if
 if(dir = 4)
 {
 dir = 1;
 }//end if
}

int array[][] setSquareWhite(int array[][]], int square[])
{

 int i = square[0];
 int j = square[1];
 array[i][j] = 1;
 return array;
}//end setSquareWhite

//function to mark square as black
int array[][] setSquareBlack(int array[][]], int square[])
{

 int i = square[0];
 int j = square[1];
 array[i][j] = 2;
 return array;
}//end setSquareBlack


//function to set next square array
int next[] setNextSquare(int next[], int dir)
{
 if(dir = 1)
 {
 next[1] = next[1] + 1;
 }//end if
 if(dir = 2)
 {
 next[0] = next[0] + 1;
 }//end if
if(dir = 3)
{
next[1] = next[1] - 1;
}//end if
if(dir = 4)
{
next[0] = next[0] - 1;
}//end if

return next;
}//end setNextSquare()

//function to set current location square
int loc[] setCurrentSquare(int next[])
{
 loc[0] = next[0];
 loc[1] = next[1];
}//end setCurrentSquare()

//function to mark found object1 location
int obj[] foundObj1(int next[])
{
 obj[0] = next[0];
 obj[1] = next[1];
}//end foundObj1()

//function to mark found object2 location
int obj[] foundObj2(int next[])
{
 obj[0] = next[0];
 obj[1] = next[1];
}//end foundObj2()

//function to calculate angle to turn to face object
float object_dir[] findObjectAngle(int loc[], int obj[])
{
 float i =(float) (obj[0] - loc[0]);
 float j =(float) (obj[1] - loc[1]);
 float k;
 float y = (i*i) + (j*j);
 k = sqrt(y);
 float x;
 x = j/k;
 float param = asin(x);
 float object_dir[2] = {k, param};
 return(object_dir[]);
}//end findObjectAngle()
 
//function to return to the first square
void goHome(int cur[], int start[])
{

}//end goHome()
 
